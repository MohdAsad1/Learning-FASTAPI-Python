# Learning FAST API

1 - FastAPI is a fast, modern Python framework for building APIs.
2 -  It's easy to learn and perfect for both beginners and professionals.
3 - FastAPI auto-generates interactive docs.
4 - Python type hints make your code safer and cleaner.
5 - You can run your app using Uvicorn.
FastAPI is a modern, high‚Äëperformance Python framework for building APIs quickly and correctly.

-------------------------------------------------------------------------------------
# Creating Venv and Activating the venv 

python -m venv venv
source venv/bin/activate
pip install django

----------------------------------------------------------------------------------------
‚úÖ Key Features

‚ö° Very fast (built on Starlette + Pydantic)
üß† Automatic data validation & type hints
üìÑ Auto‚Äëgenerated API docs (Swagger & ReDoc)
üß© Easy to learn and write clean code
üîê Easy authentication & dependency injection
Async support (async/await)

----------------------------------------------------------------------------
‚úÖ When Should You Use FastAPI?
Use FastAPI when you want:

REST APIs & microservices
High‚Äëperformance backend
Clean request validation
Fast setup (less boilerplate than Django)

===============================================================================================
üü¢ Step 1: Create Virtual Environment
python -m venv venvsource venv/bin/activate      

üü¢ Step 2: Install FastAPI & Server
FastAPI needs an ASGI server like Uvicorn:
pip install fastapi uvicornShow more lines

üü¢ Step 3: Create Your First FastAPI App
Create a file named main.py

from fastapi import FastAPI

app = FastAPI()

@app.get("/")def read_root():    
return {"message": "Hello FastAPI"}

üü¢ Step 4: Run the Server
uvicorn main:app --reload

Open in browser:
‚úÖ API: http://127.0.0.1:8000
‚úÖ Swagger Docs: http://127.0.0.1:8000/docs
‚úÖ ReDoc: http://127.0.0.1:8000/redoc


‚úÖ FastAPI Project Structure (Basic)
project/
‚îÇ‚îÄ‚îÄ main.py
‚îÇ‚îÄ‚îÄ venv/
‚îÇ‚îÄ‚îÄ requirements.txt


‚úÖ Basic Concepts in FastAPI

1Ô∏è‚É£ Path Operations (EndPoints)

@app.get("/users")
def get_users():    
  return [{"id": 1, "name": "Asad"}]

-------------------------------------------------------------------------------------------------
WHAT IS ROUTING IN FASTAPI?
HTTP methods:

@app.get()
@app.post()
@app.put()
@app.delete()
@app.patch()

----------------------------------------------------------------------------------------------------
2Ô∏è‚É£ Path Parameters
@app.get("/users/{user_id}")
def get_user(user_id: int):
  return {"user_id": user_id}

‚úÖ FastAPI validates user_id automatically!

3Ô∏è‚É£ Query Parameters
@app.get("/items/")
def read_item(skip: int = 0, limit: int = 10):
  return {"skip": skip, "limit": limit}

URL:
/items/?skip=5&limit=20


4Ô∏è‚É£ Request Body (Pydantic Models)
FastAPI uses Pydantic models for validation.
from pydantic import BaseModel
class User(BaseModel):
  name: str    
  age: int
  email: str
@app.post("/users/")
def create_user(user: User):
return user


‚úÖ Auto validation
‚úÖ Auto documentation
‚úÖ Type safety

5Ô∏è‚É£ Response Model
class UserResponse(BaseModel):
  name: str
  email: str
@app.post("/users/", response_model=UserResponse)
  def create_user(user: User):
  return userShow more lines

Only allowed fields are returned.

6Ô∏è‚É£ Status Codes
from fastapi import status
@app.post("/login", status_code=status.HTTP_201_CREATED)
  def login():
  return {"message": "Logged in"}

7Ô∏è‚É£ Async Routes (Important)
@app.get("/async")
async def async_route():
  return {"msg": "Async works"}

‚úÖ Use async when doing:

DB calls
HTTP requests
IO operations


8Ô∏è‚É£ Error Handling
from fastapi import HTTPException
@app.get("/items/{id}")
def read_item(id: int):
  if id == 0:
    raise HTTPException(status_code=404, detail="Item not found")    
  return {"id": id}


‚úÖ Routers (Like Django Apps)
Create routers/users.py

from fastapi import APIRouterrouter = APIRouter(prefix="/users", tags=["Users"])
@router.get("/")def list_users():
  return []

Register Router in main.py
from fastapi import FastAPI
from routers import users
app = FastAPI()
app

‚úÖ Dependency Injection (Powerful Feature)
from fastapi import Depends
def common_params(q: str = None):
  return q

@app.get("/items/")
def read_items(q=Depends(common_params)):
  return {"q": q}

‚úÖ Authentication Basics (Very Simple Example)
from fastapi import Header

@app.get("/secure")
def secure(token: str = Header(...)):
  if token != "secret":
    return {"error": "Invalid token"}
  return {"success": True}

‚úÖ FastAPI vs Django REST Framework (Quick Comparison)

Feature - Fast API - DRF

Speed -‚ö°Very Fast - Slower
Docs - Auto - Manual
Validation - Built‚Äëin - Serializer based
Async - Native - Limited
Admin Panel - NO - Yes
------------------------------------------------------------------------------
Why Pydantic is used in FastAPI
FastAPI uses Pydantic to:

‚úÖ Validate request data (JSON body, query params, path params)
‚úÖ Convert data types automatically
‚úÖ Define request & response schemas
‚úÖ Generate OpenAPI / Swagger docs automatically
‚úÖ Catch errors early with clear messages

Pydantic ensures that the data coming into your FastAPI app is valid, well‚Äëtyped, and structured.

from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
    email: str
-----------------------------------------------
from fastapi import FastAPI

app = FastAPI()

@app.post("/users/")
def create_user(user: User):
    return user
----------------------------------------------
{
  "name": "Asad",
  "age": "25",
  "email": "asad@example.com"
}

------------------------------------------------------
Single Pydantic Model Showing All Features of pydentic

from __future__ import annotations

from typing import Optional, List, Dict, Any, Literal
from datetime import datetime
from pydantic import (
    BaseModel,
    Field,
    EmailStr,
    HttpUrl,
    ConfigDict,
    field_validator,
    model_validator,
    computed_field,
)

class UserAllFeatures(BaseModel):
    # =========================
    # FEATURE 1: Model Config (ORM support + extra field control)
    # - from_attributes=True  -> ORM support (like SQLAlchemy objects)
    # - extra="forbid"        -> reject unknown fields (strict API contract)
    # =========================
    model_config = ConfigDict(from_attributes=True, extra="forbid")

    # =========================
    # FEATURE 2: Type hints (core schema definition)
    # =========================
    id: int

    # =========================
    # FEATURE 3: Field constraints + metadata (min/max length, examples, description)
    # =========================
    username: str = Field(
        ...,
        min_length=3,
        max_length=20,
        description="Public username (3‚Äì20 chars)",
        examples=["asad_dev"]
    )

    # =========================
    # FEATURE 4: Built-in validators via special types
    # - EmailStr validates email format
    # - HttpUrl validates URL format
    # =========================
    email: EmailStr
    website: Optional[HttpUrl] = None

    # =========================
    # FEATURE 5: Optional fields + default values
    # =========================
    is_active: bool = True
    bio: Optional[str] = Field(default=None, max_length=150)

    # =========================
    # FEATURE 6: Numeric constraints (gt/lt etc.)
    # =========================
    age: int = Field(..., gt=0, lt=120)

    # =========================
    # FEATURE 7: Literal / Enum-like constraints (allowed fixed values)
    # =========================
    role: Literal["admin", "user", "viewer"] = "user"

    # =========================
    # FEATURE 8: List / nested structures (complex JSON)
    # =========================
    tags: List[str] = Field(default_factory=list)
    preferences: Dict[str, Any] = Field(default_factory=dict)

    # =========================
    # FEATURE 9: Auto timestamps using default_factory
    # =========================
    created_at: datetime = Field(default_factory=datetime.utcnow)

    # =========================
    # FEATURE 10: Custom field validator (single-field validation)
    # =========================
    @field_validator("username")
    @classmethod
    def username_must_be_alnum_underscore(cls, v: str) -> str:
        # allow letters, digits, underscore only
        import re
        if not re.fullmatch(r"[A-Za-z0-9_]+", v):
            raise ValueError("username must contain only letters, digits, and underscore")
        return v

    # =========================
    # FEATURE 11: Model-level validator (cross-field validation)
    # - validates multiple fields together
    # =========================
    @model_validator(mode="after")
    def validate_admin_age(self) -> "UserAllFeatures":
        if self.role == "admin" and self.age < 18:
            raise ValueError("admin must be at least 18 years old")
        return self

    # =========================
    # FEATURE 12: Computed field (derived field in output)
    # - appears in serialization output
    # =========================
    @computed_field
    @property
    def display_name(self) -> str:
        # Example derived field used in responses
        return f"{self.username} ({self.role})"

=========================================================================================================

CRUD RSET Apis (GET, POST, PUT, PATCH, and DELETE)

# CODE
from main import Student
from fastapi import FastAPI, status
from fastapi.exceptions import HTTPException
from pydantic import BaseModel


books = [
    {
        "id" : 1, 
        "title" : "The Alchemist", 
        "author" : "Paulo Coelho", 
        "publish_date" : "1988-01-01"
    },
    {
        "id" : 2, 
        "title" : "The God of Small Things", 
        "author" : "Arundhati Roy", 
        "publish_date" : "1997-04-04"
    },
    {
        "id" : 3, 
        "title" : "The White Tiger", 
        "author" : "Aravind Adiga", 
        "publish_date" : "2008-01-01"
    },
    {
        "id" : 4, 
        "title" : "The Palace of Illusions", 
        "author" : "Chitra Banerjee Divakaruni", 
        "publish_date" : "2008-02-12"
    },
]


app = FastAPI()

@app.get("/book")
def get_book():
    return books

@app.get("/book/{book_id}")
def get_book(book_id: int):
    for book in books:
        if book['id'] == book_id:
            return book

    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail= "Book not found")


class Book(BaseModel):
    id: int
    title: str
    author: str
    publish_date: str

@app.post("/book")
def create_book(book: Book):
    new_book = book.model_dump()
    books.append(new_book)

class BookUpdate(BaseModel):
    title: str
    author: str
    publish_date: str

@app.put("/book/{book_id}")
def update_book(book_id: int, book_update: BookUpdate):
    for book in books:
        if book['id'] == book_id:
            book['title'] = book_update.title
            book['author'] = book_update.author
            book['publish_date'] = book_update.publish_date
            return book

    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail= "Book not found")

@app.delete("/book/{book_id}")
def delete_book(book_id:int):
    for book in books:
        if book['id'] == book_id:
            books.remove(book)
            return {"Message" : "Our Book Deleted"}

    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail= "Book not found")

=========================================================================================================================
#  SQL Alchemy ORM -

SQLAlchemy ORM in FastAPI is the combination of FastAPI (the web framework) with SQLAlchemy‚Äôs ORM (Object-Relational Mapper) to interact with relational databases using Python classes instead of writing raw SQL.
In short:

SQLAlchemy ORM lets you define models (Python classes) that map to DB tables, run queries, and manage transactions/sessions.
FastAPI wires those models into your API endpoints, typically returning Pydantic models as responses.
‚úÖ Type-safe models: Define tables as Python classes.
‚úÖ Relationships: Express One-to-Many, Many-to-Many, etc.
‚úÖ Migrations: Works with Alembic for schema versioning.
‚úÖ Sync or Async: Choose traditional synchronous engine or async engine (asyncpg/aiosqlite) with FastAPI.

from sqlalchemy import Column, Integer, String, Date, ForeignKey
from sqlalchemy.orm import relationship
from .database import Base

# Models.py
class Author(Base):
    __tablename__ = "authors"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, index=True)

    books = relationship("Book", back_populates="author", cascade="all, delete-orphan")

class Book(Base):
    __tablename__ = "books"
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(200), nullable=False, index=True)
    publish_date = Column(Date, nullable=False)
    author_id = Column(Integer, ForeignKey("authors.id", ondelete="CASCADE"), nullable=False)

    author = relationship("Author", back_populates="books")

=========================================================================================================================
WHAT IS AUTHENTICATION VS AUTHORIZATION?

Authentication:
This is the process of verifying who a user is ‚Äî usually through a login system (like email + password). Only authenticated users should access certain parts of your API.

Authorization:
After authentication, authorization determines what the authenticated user is allowed to do ‚Äî e.g., regular user vs admin.

‚Ä¢ Simple Example:
Authentication = User proves  they user123
Authorization = user123 can view their own data but not delete another user's data
------------------------------------------------------------------------------------------------------------------------------
# JWT in FastAPI?
JWT is a signed token you issue after verifying a user‚Äôs credentials. 
Clients send it on each request (usually in the Authorization: Bearer <token> header), and your API verifies it to authorize access.

@ Common flow :-
User logs in with username/password ‚Üí you verify + issue JWT (short‚Äëlived).
Client stores token (e.g., in memory or secure storage).
For each protected API call, client sends Authorization: Bearer <token>.
Server verifies the token‚Äôs signature, expiry, and claims ‚Üí allows/denies.

-------------------------------------------------------------------------------------------------------------------------------
OAUTH2 PASSWORD FLOW WORKS IN

FastAPI uses OAuth2 with Password and Bearer tokens:
1. The client sends username + password to a login endpoint
2. Server checks credentials
3. Server returns a JWT token
4. Client sends the token in an Authorization: Bearer < token> header
5. FastAPI checks token before allowing access to protected routes
User Login --------> Server Creates JWT ----------> Client Stores Token -----------> Client Sends Token ---------> Server Validates Token --------> Access Granted

---------------------------------------------------------------------------------------------------------------------------------

üîê Passlib Argon2 ‚Äî What It Is
argon2 in Passlib is an implementation of the Argon2 password hashing algorithm, which is considered one of the strongest and most secure password hashing algorithms today.

üîê What is python-jose?
python-jose is a Python library used for:

Creating JWT tokens (signing)
Verifying JWT tokens (decoding)
Handling JOSE standards (JWT, JWS, JWE)

It is commonly used in FastAPI for authentication.
