# Learning FAST API

1 - FastAPI is a fast, modern Python framework for building APIs.
2 -  It's easy to learn and perfect for both beginners and professionals.
3 - FastAPI auto-generates interactive docs.
4 - Python type hints make your code safer and cleaner.
5 - You can run your app using Uvicorn.
FastAPI is a modern, highâ€‘performance Python framework for building APIs quickly and correctly.

-------------------------------------------------------------------------------------
# Creating Venv and Activating the venv 

python -m venv venv
source venv/bin/activate
pip install django

----------------------------------------------------------------------------------------
âœ… Key Features

âš¡ Very fast (built on Starlette + Pydantic)
ðŸ§  Automatic data validation & type hints
ðŸ“„ Autoâ€‘generated API docs (Swagger & ReDoc)
ðŸ§© Easy to learn and write clean code
ðŸ” Easy authentication & dependency injection
Async support (async/await)

----------------------------------------------------------------------------
âœ… When Should You Use FastAPI?
Use FastAPI when you want:

REST APIs & microservices
Highâ€‘performance backend
Clean request validation
Fast setup (less boilerplate than Django)

===============================================================================================
ðŸŸ¢ Step 1: Create Virtual Environment
python -m venv venvsource venv/bin/activate      

ðŸŸ¢ Step 2: Install FastAPI & Server
FastAPI needs an ASGI server like Uvicorn:
pip install fastapi uvicornShow more lines

ðŸŸ¢ Step 3: Create Your First FastAPI App
Create a file named main.py

from fastapi import FastAPI

app = FastAPI()

@app.get("/")def read_root():    
return {"message": "Hello FastAPI"}

ðŸŸ¢ Step 4: Run the Server
uvicorn main:app --reload

Open in browser:
âœ… API: http://127.0.0.1:8000
âœ… Swagger Docs: http://127.0.0.1:8000/docs
âœ… ReDoc: http://127.0.0.1:8000/redoc


âœ… FastAPI Project Structure (Basic)
project/
â”‚â”€â”€ main.py
â”‚â”€â”€ venv/
â”‚â”€â”€ requirements.txt


âœ… Basic Concepts in FastAPI

1ï¸âƒ£ Path Operations (EndPoints)

@app.get("/users")
def get_users():    
  return [{"id": 1, "name": "Asad"}]

-------------------------------------------------------------------------------------------------
WHAT IS ROUTING IN FASTAPI?
HTTP methods:

@app.get()
@app.post()
@app.put()
@app.delete()
@app.patch()

----------------------------------------------------------------------------------------------------
2ï¸âƒ£ Path Parameters
@app.get("/users/{user_id}")
def get_user(user_id: int):
  return {"user_id": user_id}

âœ… FastAPI validates user_id automatically!

3ï¸âƒ£ Query Parameters
@app.get("/items/")
def read_item(skip: int = 0, limit: int = 10):
  return {"skip": skip, "limit": limit}

URL:
/items/?skip=5&limit=20


4ï¸âƒ£ Request Body (Pydantic Models)
FastAPI uses Pydantic models for validation.
from pydantic import BaseModel
class User(BaseModel):
  name: str    
  age: int
  email: str
@app.post("/users/")
def create_user(user: User):
return user


âœ… Auto validation
âœ… Auto documentation
âœ… Type safety

5ï¸âƒ£ Response Model
class UserResponse(BaseModel):
  name: str
  email: str
@app.post("/users/", response_model=UserResponse)
  def create_user(user: User):
  return userShow more lines

Only allowed fields are returned.

6ï¸âƒ£ Status Codes
from fastapi import status
@app.post("/login", status_code=status.HTTP_201_CREATED)
  def login():
  return {"message": "Logged in"}

7ï¸âƒ£ Async Routes (Important)
@app.get("/async")
async def async_route():
  return {"msg": "Async works"}

âœ… Use async when doing:

DB calls
HTTP requests
IO operations


8ï¸âƒ£ Error Handling
from fastapi import HTTPException
@app.get("/items/{id}")
def read_item(id: int):
  if id == 0:
    raise HTTPException(status_code=404, detail="Item not found")    
  return {"id": id}


âœ… Routers (Like Django Apps)
Create routers/users.py

from fastapi import APIRouterrouter = APIRouter(prefix="/users", tags=["Users"])
@router.get("/")def list_users():
  return []

Register Router in main.py
from fastapi import FastAPI
from routers import users
app = FastAPI()
app

âœ… Dependency Injection (Powerful Feature)
from fastapi import Depends
def common_params(q: str = None):
  return q

@app.get("/items/")
def read_items(q=Depends(common_params)):
  return {"q": q}

âœ… Authentication Basics (Very Simple Example)
from fastapi import Header

@app.get("/secure")
def secure(token: str = Header(...)):
  if token != "secret":
    return {"error": "Invalid token"}
  return {"success": True}

âœ… FastAPI vs Django REST Framework (Quick Comparison)

Feature - Fast API - DRF

Speed -âš¡Very Fast - Slower
Docs - Auto - Manual
Validation - Builtâ€‘in - Serializer based
Async - Native - Limited
Admin Panel - NO - Yes
------------------------------------------------------------------------------
Why Pydantic is used in FastAPI
FastAPI uses Pydantic to:

âœ… Validate request data (JSON body, query params, path params)
âœ… Convert data types automatically
âœ… Define request & response schemas
âœ… Generate OpenAPI / Swagger docs automatically
âœ… Catch errors early with clear messages

Pydantic ensures that the data coming into your FastAPI app is valid, wellâ€‘typed, and structured.

from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
    email: str
-----------------------------------------------
from fastapi import FastAPI

app = FastAPI()

@app.post("/users/")
def create_user(user: User):
    return user
----------------------------------------------
{
  "name": "Asad",
  "age": "25",
  "email": "asad@example.com"
}

------------------------------------------------------
Single Pydantic Model Showing All Features of pydentic

from __future__ import annotations

from typing import Optional, List, Dict, Any, Literal
from datetime import datetime
from pydantic import (
    BaseModel,
    Field,
    EmailStr,
    HttpUrl,
    ConfigDict,
    field_validator,
    model_validator,
    computed_field,
)

class UserAllFeatures(BaseModel):
    # =========================
    # FEATURE 1: Model Config (ORM support + extra field control)
    # - from_attributes=True  -> ORM support (like SQLAlchemy objects)
    # - extra="forbid"        -> reject unknown fields (strict API contract)
    # =========================
    model_config = ConfigDict(from_attributes=True, extra="forbid")

    # =========================
    # FEATURE 2: Type hints (core schema definition)
    # =========================
    id: int

    # =========================
    # FEATURE 3: Field constraints + metadata (min/max length, examples, description)
    # =========================
    username: str = Field(
        ...,
        min_length=3,
        max_length=20,
        description="Public username (3â€“20 chars)",
        examples=["asad_dev"]
    )

    # =========================
    # FEATURE 4: Built-in validators via special types
    # - EmailStr validates email format
    # - HttpUrl validates URL format
    # =========================
    email: EmailStr
    website: Optional[HttpUrl] = None

    # =========================
    # FEATURE 5: Optional fields + default values
    # =========================
    is_active: bool = True
    bio: Optional[str] = Field(default=None, max_length=150)

    # =========================
    # FEATURE 6: Numeric constraints (gt/lt etc.)
    # =========================
    age: int = Field(..., gt=0, lt=120)

    # =========================
    # FEATURE 7: Literal / Enum-like constraints (allowed fixed values)
    # =========================
    role: Literal["admin", "user", "viewer"] = "user"

    # =========================
    # FEATURE 8: List / nested structures (complex JSON)
    # =========================
    tags: List[str] = Field(default_factory=list)
    preferences: Dict[str, Any] = Field(default_factory=dict)

    # =========================
    # FEATURE 9: Auto timestamps using default_factory
    # =========================
    created_at: datetime = Field(default_factory=datetime.utcnow)

    # =========================
    # FEATURE 10: Custom field validator (single-field validation)
    # =========================
    @field_validator("username")
    @classmethod
    def username_must_be_alnum_underscore(cls, v: str) -> str:
        # allow letters, digits, underscore only
        import re
        if not re.fullmatch(r"[A-Za-z0-9_]+", v):
            raise ValueError("username must contain only letters, digits, and underscore")
        return v

    # =========================
    # FEATURE 11: Model-level validator (cross-field validation)
    # - validates multiple fields together
    # =========================
    @model_validator(mode="after")
    def validate_admin_age(self) -> "UserAllFeatures":
        if self.role == "admin" and self.age < 18:
            raise ValueError("admin must be at least 18 years old")
        return self

    # =========================
    # FEATURE 12: Computed field (derived field in output)
    # - appears in serialization output
    # =========================
    @computed_field
    @property
    def display_name(self) -> str:
        # Example derived field used in responses
        return f"{self.username} ({self.role})"
